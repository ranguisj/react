{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nimport { hasOwnProperty, isArray, isBoolean, isFunction, isObject, isString, isUndefined } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\nexport function parseUpdateArgs(args) {\n  let data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n\n  return data;\n}\n/**\n *\n * @param options\n */\n\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(`'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`);\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n} // function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  } // Ignore onComplete as its never used\n\n\n  const NOOP = () => {};\n\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n  /**\n   * .onSnapshot(Function...\n   */\n\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n\n\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n\n\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return {\n    snapshotListenOptions,\n    callback,\n    onNext,\n    onError\n  };\n}","map":{"version":3,"sources":["/Users/jeremyranguis/greatwanderline/package/firebase-jwt/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"names":["hasOwnProperty","isArray","isBoolean","isFunction","isObject","isString","isUndefined","FirestoreFieldPath","fromDotSeparatedString","extractFieldPathData","data","segmenets","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","i","key","value","_toPath","parseSetOptions","options","out","merge","mergeFields","field","path","e","message","push","isPartialObserver","input","next","error","complete","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","observer","bind","includeMetadataChanges"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges =\n      args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"]},"metadata":{},"sourceType":"module"}