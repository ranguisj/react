{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from './FirestoreTransaction';\nlet transactionId = 0;\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\n\nconst generateTransactionId = () => transactionId++;\n\nexport default class FirestoreTransactionHandler {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._pending = {};\n\n    this._firestore.emitter.addListener(this._firestore.eventNameForApp('firestore_transaction_event'), this._onTransactionEvent.bind(this));\n  }\n\n  _onTransactionEvent(event) {\n    switch (event.body.type) {\n      case 'update':\n        this._handleUpdate(event);\n\n        break;\n\n      case 'error':\n        this._handleError(event);\n\n        break;\n\n      case 'complete':\n        this._handleComplete(event);\n\n        break;\n    }\n  }\n\n  async _handleUpdate(event) {\n    const {\n      listenerId: id\n    } = event; // abort if no longer exists js side\n\n    if (!this._pending[id]) {\n      return this._remove(id);\n    }\n\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta; // clear any saved state from previous transaction runs\n\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult;\n\n    try {\n      const possiblePromise = updateFunction(transaction); // validate user has returned a promise in their update function\n\n      if (!possiblePromise || !possiblePromise.then) {\n        throw new Error(\"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\");\n      }\n\n      pendingResult = await possiblePromise;\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    } // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n\n\n    if (updateFailed || finalError) {\n      return reject(finalError);\n    } // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n\n\n    transaction._pendingResult = pendingResult; // send the buffered update/set/delete commands for native to process\n\n    return this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n  /**\n   * Reject the promise with a native error event\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleError(event) {\n    const {\n      listenerId: id,\n      body\n    } = event;\n    const {\n      error\n    } = body;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const {\n      meta\n    } = this._pending[id];\n\n    if (meta && error) {\n      const errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n      meta.reject(errorAndStack);\n    }\n  }\n  /**\n   * Once the transaction has completed on native, resolve the promise with any\n   * pending results\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleComplete(event) {\n    const {\n      listenerId: id\n    } = event;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n\n    if (meta) {\n      meta.resolve(transaction._pendingResult);\n    }\n  }\n  /**\n   * Internally adds a transaction execution function to the queue\n   *\n   * @param updateFunction\n   * @returns {Promise<any>}\n   * @private\n   */\n\n\n  _add(updateFunction) {\n    const id = generateTransactionId();\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new FirestoreTransaction(this._firestore, meta)\n    };\n    return new Promise((resolve, reject) => {\n      this._firestore.native.transactionBegin(id);\n\n      meta.resolve = result => {\n        this._remove(id);\n\n        resolve(result);\n      };\n\n      meta.reject = error => {\n        this._remove(id);\n\n        reject(error);\n      };\n    });\n  }\n  /**\n   * Internally removes the transaction once it has resolved\n   * or rejected\n   *\n   * @param id\n   * @private\n   */\n\n\n  _remove(id) {\n    this._firestore.native.transactionDispose(id);\n\n    delete this._pending[id];\n  }\n\n}","map":{"version":3,"sources":["/Users/jeremyranguis/greatwanderline/package/firebase-jwt/node_modules/@react-native-firebase/firestore/lib/FirestoreTransactionHandler.js"],"names":["NativeError","FirestoreTransaction","transactionId","generateTransactionId","FirestoreTransactionHandler","constructor","firestore","_firestore","_pending","emitter","addListener","eventNameForApp","_onTransactionEvent","bind","event","body","type","_handleUpdate","_handleError","_handleComplete","listenerId","id","_remove","meta","transaction","updateFunction","reject","_prepare","finalError","updateFailed","pendingResult","possiblePromise","then","Error","exception","_pendingResult","native","transactionApplyBuffer","_commandBuffer","error","errorAndStack","fromEvent","stack","resolve","_add","split","slice","join","Promise","transactionBegin","result","transactionDispose"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreTransaction from './FirestoreTransaction';\n\nlet transactionId = 0;\n\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\nconst generateTransactionId = () => transactionId++;\n\nexport default class FirestoreTransactionHandler {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._pending = {};\n    this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp('firestore_transaction_event'),\n      this._onTransactionEvent.bind(this),\n    );\n  }\n\n  _onTransactionEvent(event) {\n    switch (event.body.type) {\n      case 'update':\n        this._handleUpdate(event);\n        break;\n      case 'error':\n        this._handleError(event);\n        break;\n      case 'complete':\n        this._handleComplete(event);\n        break;\n    }\n  }\n\n  async _handleUpdate(event) {\n    const { listenerId: id } = event;\n\n    // abort if no longer exists js side\n    if (!this._pending[id]) {\n      return this._remove(id);\n    }\n\n    const { meta, transaction } = this._pending[id];\n    const { updateFunction, reject } = meta;\n\n    // clear any saved state from previous transaction runs\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult;\n\n    try {\n      const possiblePromise = updateFunction(transaction);\n\n      // validate user has returned a promise in their update function\n      if (!possiblePromise || !possiblePromise.then) {\n        throw new Error(\n          \"firebase.firestore().runTransaction(*) 'updateFunction' must return a Promise.\",\n        );\n      }\n\n      pendingResult = await possiblePromise;\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    }\n\n    // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n    if (updateFailed || finalError) {\n      return reject(finalError);\n    }\n\n    // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n    transaction._pendingResult = pendingResult;\n\n    // send the buffered update/set/delete commands for native to process\n    return this._firestore.native.transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n\n  /**\n   * Reject the promise with a native error event\n   *\n   * @param event\n   * @private\n   */\n  _handleError(event) {\n    const { listenerId: id, body } = event;\n    const { error } = body;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta } = this._pending[id];\n\n    if (meta && error) {\n      const errorAndStack = NativeError.fromEvent(error, 'firestore', meta.stack);\n      meta.reject(errorAndStack);\n    }\n  }\n\n  /**\n   * Once the transaction has completed on native, resolve the promise with any\n   * pending results\n   *\n   * @param event\n   * @private\n   */\n  _handleComplete(event) {\n    const { listenerId: id } = event;\n\n    if (!this._pending[id]) {\n      return;\n    }\n\n    const { meta, transaction } = this._pending[id];\n    if (meta) {\n      meta.resolve(transaction._pendingResult);\n    }\n  }\n\n  /**\n   * Internally adds a transaction execution function to the queue\n   *\n   * @param updateFunction\n   * @returns {Promise<any>}\n   * @private\n   */\n  _add(updateFunction) {\n    const id = generateTransactionId();\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n'),\n    };\n\n    this._pending[id] = {\n      meta,\n      transaction: new FirestoreTransaction(this._firestore, meta),\n    };\n\n    return new Promise((resolve, reject) => {\n      this._firestore.native.transactionBegin(id);\n\n      meta.resolve = result => {\n        this._remove(id);\n        resolve(result);\n      };\n\n      meta.reject = error => {\n        this._remove(id);\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Internally removes the transaction once it has resolved\n   * or rejected\n   *\n   * @param id\n   * @private\n   */\n  _remove(id) {\n    this._firestore.native.transactionDispose(id);\n    delete this._pending[id];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}