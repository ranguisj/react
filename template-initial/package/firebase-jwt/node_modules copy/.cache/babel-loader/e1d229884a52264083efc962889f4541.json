{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN'\n};\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true\n};\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection'; // Cursors\n\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f,\n      fieldPath: f.fieldPath._toArray()\n    }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n  /**\n   * Options\n   */\n\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n  /**\n   * Collection Group Query\n   */\n\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n  /**\n   * Limit\n   */\n\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n  /**\n   * limitToLast\n   */\n\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n  /**\n   * Filters\n   */\n\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' || OPERATORS[operator] === 'NOT_IN';\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true)\n    };\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n    let hasNotEqual;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i]; // Skip if no inequality\n\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        } //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n\n\n        hasNotEqual = true;\n      } // Set the first inequality\n\n\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      } // Check the set value is the same as the new one\n\n\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(`Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`);\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n    let hasNotIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n        }\n\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\");\n        }\n\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\");\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\");\n        }\n\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\");\n        }\n\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\");\n        }\n\n        hasNotIn = true;\n      }\n    }\n  }\n  /**\n   * Orders\n   */\n\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n    };\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    } // Skip if no where filters\n\n\n    if (this._filters.length === 0) {\n      return;\n    } // Ensure the first order field path is equal to the inequality filter field path\n\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(`Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`);\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(`Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `);\n          }\n        }\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/jeremyranguis/greatwanderline/package/firebase-jwt/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"names":["isNumber","buildNativeArray","generateNativeData","DOCUMENT_ID","OPERATORS","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","NOT_EQUAL","DIRECTIONS","asc","desc","FirestoreQueryModifiers","constructor","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","_copy","newInstance","filters","map","f","fieldPath","_toArray","orders","options","limit","limitToLast","startAt","startAfter","endAt","endBefore","type","setFieldsCursor","cursor","fields","hasStart","hasEnd","asCollectionGroupQuery","isCollectionGroupQuery","isValidLimit","Math","floor","isValidLimitToLast","validatelimitToLast","length","Error","isValidOperator","operator","isEqualOperator","isInOperator","where","opStr","value","filter","concat","validateWhere","hasInequality","hasNotEqual","i","_toPath","hasArrayContains","hasArrayContainsAny","hasIn","hasNotIn","isValidDirection","directionStr","toLowerCase","orderBy","order","direction","validateOrderBy","$","set","Set","size","filterFieldPath","k","orderFieldPath"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\nimport { DOCUMENT_ID } from './FirestoreFieldPath';\n\nconst OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({ ...f, fieldPath: f.fieldPath._toArray() }));\n  }\n\n  get orders() {\n    return this._orders;\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isInOperator(operator) {\n    return (\n      OPERATORS[operator] === 'IN' ||\n      OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' ||\n      OPERATORS[operator] === 'NOT_IN'\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    let hasInequality;\n    let hasNotEqual;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!hasInequality) {\n        hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && hasInequality) {\n        if (hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    let hasArrayContains;\n    let hasArrayContainsAny;\n    let hasIn;\n    let hasNotIn;\n\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'in' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\",\n          );\n        }\n\n        hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'in' filter.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (hasNotEqual) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\",\n          );\n        }\n\n        if (hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath._toPath(),\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath);\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (this._filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < this._filters.length; i++) {\n      const filter = this._filters[i];\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}