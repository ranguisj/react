{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nimport { isArray, isNull, isObject, isString, isUndefined } from '@react-native-firebase/app/lib/common';\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreDocumentSnapshot from './FirestoreDocumentSnapshot';\nimport FirestoreFieldPath, { fromDotSeparatedString } from './FirestoreFieldPath';\nimport FirestoreQuerySnapshot from './FirestoreQuerySnapshot';\nimport { parseSnapshotArgs } from './utils';\nlet _id = 0;\nexport default class FirestoreQuery {\n  constructor(firestore, collectionPath, modifiers, queryName) {\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n    this._queryName = queryName;\n  }\n\n  get firestore() {\n    return this._firestore;\n  }\n\n  _handleQueryCursor(cursor, docOrField, fields) {\n    const modifiers = this._modifiers._copy();\n\n    if (isUndefined(docOrField)) {\n      throw new Error(`firebase.firestore().collection().${cursor}(*) Expected a DocumentSnapshot or list of field values but got undefined.`);\n    } // Handles cases where the first arg is a DocumentSnapshot\n\n\n    if (docOrField instanceof FirestoreDocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new Error(`firebase.firestore().collection().${cursor}(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.`);\n      }\n\n      const documentSnapshot = docOrField;\n\n      if (!documentSnapshot.exists) {\n        throw new Error(`firebase.firestore().collection().${cursor}(*) Can't use a DocumentSnapshot that doesn't exist.`);\n      }\n\n      const currentOrders = modifiers.orders;\n      const values = [];\n\n      for (let i = 0; i < currentOrders.length; i++) {\n        const order = currentOrders[i]; //skip if fieldPath is '__name__'\n\n        if (order.fieldPath === '__name__') {\n          continue;\n        }\n\n        const value = documentSnapshot.get(order.fieldPath);\n\n        if (value === undefined) {\n          throw new Error(`firebase.firestore().collection().${cursor}(*) You are trying to start or end a query using a document for which the field '${order.fieldPath}' (used as the orderBy) does not exist.`);\n        }\n\n        values.push(value);\n      } // Based on https://github.com/invertase/react-native-firebase/issues/2854#issuecomment-552986650\n\n\n      if (modifiers._orders.length) {\n        const lastOrder = modifiers._orders[modifiers._orders.length - 1]; //push '__name__' field only if not present already\n\n        if (lastOrder.fieldPath !== '__name__') {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: lastOrder.direction\n          });\n        }\n      } else {\n        modifiers._orders.push({\n          fieldPath: '__name__',\n          direction: 'ASCENDING'\n        });\n      }\n\n      if (this._modifiers.isCollectionGroupQuery()) {\n        values.push(documentSnapshot.ref.path);\n      } else {\n        values.push(documentSnapshot.id);\n      }\n\n      return modifiers.setFieldsCursor(cursor, values);\n    }\n    /**\n     * Assumes list of field values to query by. Orders must be of equal length.\n     */\n\n\n    const allFields = [docOrField].concat(fields);\n\n    if (allFields.length > modifiers.orders.length) {\n      throw new Error(`firebase.firestore().collection().${cursor}(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.`);\n    }\n\n    return modifiers.setFieldsCursor(cursor, allFields);\n  }\n\n  endAt(docOrField) {\n    for (var _len = arguments.length, fields = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      fields[_key - 1] = arguments[_key];\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endAt', docOrField, fields), this._queryName);\n  }\n\n  endBefore(docOrField) {\n    for (var _len2 = arguments.length, fields = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      fields[_key2 - 1] = arguments[_key2];\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('endBefore', docOrField, fields), this._queryName);\n  }\n\n  get(options) {\n    if (!isUndefined(options) && !isObject(options)) {\n      throw new Error(\"firebase.firestore().collection().get(*) 'options' must be an object is provided.\");\n    }\n\n    if (options && options.source && options.source !== 'default' && options.source !== 'server' && options.source !== 'cache') {\n      throw new Error(\"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\");\n    }\n\n    if (!isUndefined(this._queryName)) {\n      return this._firestore.native.namedQueryGet(this._queryName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, options).then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n    }\n\n    this._modifiers.validatelimitToLast();\n\n    return this._firestore.native.collectionGet(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, options).then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n  }\n\n  isEqual(other) {\n    if (!(other instanceof FirestoreQuery)) {\n      throw new Error(\"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\");\n    } // Carry out lightweight checks first\n\n\n    if (this.firestore.app.name !== other.firestore.app.name || this._modifiers.type !== other._modifiers.type || this._modifiers.filters.length !== other._modifiers.filters.length || this._modifiers.orders.length !== other._modifiers.orders.length || this._collectionPath.relativeName !== other._collectionPath.relativeName || Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length) {\n      return false;\n    } // Carry out potentially expensive checks\n    // noinspection RedundantIfStatementJS\n\n\n    if (JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) || JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) || JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  limit(limit) {\n    if (this._modifiers.isValidLimit(limit)) {\n      throw new Error(\"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\");\n    }\n\n    const modifiers = this._modifiers._copy().limit(limit);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  limitToLast(limitToLast) {\n    if (this._modifiers.isValidLimitToLast(limitToLast)) {\n      throw new Error(\"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\");\n    }\n\n    const modifiers = this._modifiers._copy().limitToLast(limitToLast);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  onSnapshot() {\n    let snapshotListenOptions;\n    let callback;\n    let onNext;\n    let onError;\n\n    this._modifiers.validatelimitToLast();\n\n    try {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      const options = parseSnapshotArgs(args);\n      snapshotListenOptions = options.snapshotListenOptions;\n      callback = options.callback;\n      onNext = options.onNext;\n      onError = options.onError;\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().onSnapshot(*) ${e.message}`);\n    }\n\n    function handleSuccess(querySnapshot) {\n      callback(querySnapshot, null);\n      onNext(querySnapshot);\n    }\n\n    function handleError(error) {\n      callback(null, error);\n      onError(error);\n    }\n\n    const listenerId = _id++;\n\n    const onSnapshotSubscription = this._firestore.emitter.addListener(this._firestore.eventNameForApp(`firestore_collection_sync_event:${listenerId}`), event => {\n      if (event.body.error) {\n        handleError(NativeError.fromEvent(event.body.error, 'firestore'));\n      } else {\n        const querySnapshot = new FirestoreQuerySnapshot(this._firestore, this, event.body.snapshot);\n        handleSuccess(querySnapshot);\n      }\n    });\n\n    const unsubscribe = () => {\n      onSnapshotSubscription.remove();\n\n      this._firestore.native.collectionOffSnapshot(listenerId);\n    };\n\n    if (!isUndefined(this._queryName)) {\n      this._firestore.native.namedQueryOnSnapshot(this._queryName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, listenerId, snapshotListenOptions);\n    } else {\n      this._firestore.native.collectionOnSnapshot(this._collectionPath.relativeName, this._modifiers.type, this._modifiers.filters, this._modifiers.orders, this._modifiers.options, listenerId, snapshotListenOptions);\n    }\n\n    return unsubscribe;\n  }\n\n  orderBy(fieldPath, directionStr) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\");\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().orderBy(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!isUndefined(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n      throw new Error(\"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\");\n    }\n\n    if (this._modifiers.hasStart()) {\n      throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().');\n    }\n\n    if (this._modifiers.hasEnd()) {\n      throw new Error('firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().');\n    }\n\n    const modifiers = this._modifiers._copy().orderBy(path, directionStr);\n\n    try {\n      modifiers.validateOrderBy();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().orderBy() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  startAfter(docOrField) {\n    for (var _len4 = arguments.length, fields = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      fields[_key4 - 1] = arguments[_key4];\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAfter', docOrField, fields), this._queryName);\n  }\n\n  startAt(docOrField) {\n    for (var _len5 = arguments.length, fields = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      fields[_key5 - 1] = arguments[_key5];\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, this._handleQueryCursor('startAt', docOrField, fields), this._queryName);\n  }\n\n  where(fieldPath, opStr, value) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\"firebase.firestore().collection().where(*) 'fieldPath' must be a string or instance of FieldPath.\");\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().where(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!this._modifiers.isValidOperator(opStr)) {\n      throw new Error(\"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\");\n    }\n\n    if (isUndefined(value)) {\n      throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\");\n    }\n\n    if (isNull(value) && !this._modifiers.isEqualOperator(opStr)) {\n      throw new Error(\"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\");\n    }\n\n    if (this._modifiers.isInOperator(opStr)) {\n      if (!isArray(value) || !value.length) {\n        throw new Error(`firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '${opStr}' filters.`);\n      }\n\n      if (value.length > 10) {\n        throw new Error(`firebase.firestore().collection().where(_, _, *) 'value' is invalid. '${opStr}' filters support a maximum of 10 elements in the value array.`);\n      }\n    }\n\n    const modifiers = this._modifiers._copy().where(path, opStr, value);\n\n    try {\n      modifiers.validateWhere();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().where() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n}","map":{"version":3,"sources":["/Users/jeremyranguis/greatwanderline/package/firebase-jwt/node_modules/@react-native-firebase/firestore/lib/FirestoreQuery.js"],"names":["isArray","isNull","isObject","isString","isUndefined","NativeError","FirestoreDocumentSnapshot","FirestoreFieldPath","fromDotSeparatedString","FirestoreQuerySnapshot","parseSnapshotArgs","_id","FirestoreQuery","constructor","firestore","collectionPath","modifiers","queryName","_firestore","_collectionPath","_modifiers","_queryName","_handleQueryCursor","cursor","docOrField","fields","_copy","Error","length","documentSnapshot","exists","currentOrders","orders","values","i","order","fieldPath","value","get","undefined","push","_orders","lastOrder","direction","isCollectionGroupQuery","ref","path","id","setFieldsCursor","allFields","concat","endAt","endBefore","options","source","native","namedQueryGet","type","filters","then","data","validatelimitToLast","collectionGet","relativeName","isEqual","other","app","name","Object","keys","JSON","stringify","limit","isValidLimit","limitToLast","isValidLimitToLast","onSnapshot","snapshotListenOptions","callback","onNext","onError","args","e","message","handleSuccess","querySnapshot","handleError","error","listenerId","onSnapshotSubscription","emitter","addListener","eventNameForApp","event","body","fromEvent","snapshot","unsubscribe","remove","collectionOffSnapshot","namedQueryOnSnapshot","collectionOnSnapshot","orderBy","directionStr","isValidDirection","hasStart","hasEnd","validateOrderBy","startAfter","startAt","where","opStr","isValidOperator","isEqualOperator","isInOperator","validateWhere"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  isArray,\n  isNull,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport NativeError from '@react-native-firebase/app/lib/internal/NativeFirebaseError';\nimport FirestoreDocumentSnapshot from './FirestoreDocumentSnapshot';\nimport FirestoreFieldPath, { fromDotSeparatedString } from './FirestoreFieldPath';\nimport FirestoreQuerySnapshot from './FirestoreQuerySnapshot';\nimport { parseSnapshotArgs } from './utils';\n\nlet _id = 0;\n\nexport default class FirestoreQuery {\n  constructor(firestore, collectionPath, modifiers, queryName) {\n    this._firestore = firestore;\n    this._collectionPath = collectionPath;\n    this._modifiers = modifiers;\n    this._queryName = queryName;\n  }\n\n  get firestore() {\n    return this._firestore;\n  }\n\n  _handleQueryCursor(cursor, docOrField, fields) {\n    const modifiers = this._modifiers._copy();\n\n    if (isUndefined(docOrField)) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Expected a DocumentSnapshot or list of field values but got undefined.`,\n      );\n    }\n\n    // Handles cases where the first arg is a DocumentSnapshot\n    if (docOrField instanceof FirestoreDocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Too many arguments provided. Expected DocumentSnapshot or list of field values.`,\n        );\n      }\n\n      const documentSnapshot = docOrField;\n\n      if (!documentSnapshot.exists) {\n        throw new Error(\n          `firebase.firestore().collection().${cursor}(*) Can't use a DocumentSnapshot that doesn't exist.`,\n        );\n      }\n\n      const currentOrders = modifiers.orders;\n\n      const values = [];\n\n      for (let i = 0; i < currentOrders.length; i++) {\n        const order = currentOrders[i];\n        //skip if fieldPath is '__name__'\n        if (order.fieldPath === '__name__') {\n          continue;\n        }\n\n        const value = documentSnapshot.get(order.fieldPath);\n\n        if (value === undefined) {\n          throw new Error(\n            `firebase.firestore().collection().${cursor}(*) You are trying to start or end a query using a document for which the field '${order.fieldPath}' (used as the orderBy) does not exist.`,\n          );\n        }\n\n        values.push(value);\n      }\n\n      // Based on https://github.com/invertase/react-native-firebase/issues/2854#issuecomment-552986650\n      if (modifiers._orders.length) {\n        const lastOrder = modifiers._orders[modifiers._orders.length - 1];\n        //push '__name__' field only if not present already\n        if (lastOrder.fieldPath !== '__name__') {\n          modifiers._orders.push({\n            fieldPath: '__name__',\n            direction: lastOrder.direction,\n          });\n        }\n      } else {\n        modifiers._orders.push({\n          fieldPath: '__name__',\n          direction: 'ASCENDING',\n        });\n      }\n\n      if (this._modifiers.isCollectionGroupQuery()) {\n        values.push(documentSnapshot.ref.path);\n      } else {\n        values.push(documentSnapshot.id);\n      }\n\n      return modifiers.setFieldsCursor(cursor, values);\n    }\n\n    /**\n     * Assumes list of field values to query by. Orders must be of equal length.\n     */\n\n    const allFields = [docOrField].concat(fields);\n\n    if (allFields.length > modifiers.orders.length) {\n      throw new Error(\n        `firebase.firestore().collection().${cursor}(*) Too many arguments provided. The number of arguments must be less than or equal to the number of orderBy() clauses.`,\n      );\n    }\n\n    return modifiers.setFieldsCursor(cursor, allFields);\n  }\n\n  endAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endAt', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  endBefore(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('endBefore', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  get(options) {\n    if (!isUndefined(options) && !isObject(options)) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' must be an object is provided.\",\n      );\n    }\n\n    if (\n      options &&\n      options.source &&\n      options.source !== 'default' &&\n      options.source !== 'server' &&\n      options.source !== 'cache'\n    ) {\n      throw new Error(\n        \"firebase.firestore().collection().get(*) 'options' GetOptions.source must be one of 'default', 'server' or 'cache'.\",\n      );\n    }\n\n    if (!isUndefined(this._queryName)) {\n      return this._firestore.native\n        .namedQueryGet(\n          this._queryName,\n          this._modifiers.type,\n          this._modifiers.filters,\n          this._modifiers.orders,\n          this._modifiers.options,\n          options,\n        )\n        .then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n    }\n\n    this._modifiers.validatelimitToLast();\n\n    return this._firestore.native\n      .collectionGet(\n        this._collectionPath.relativeName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        options,\n      )\n      .then(data => new FirestoreQuerySnapshot(this._firestore, this, data));\n  }\n\n  isEqual(other) {\n    if (!(other instanceof FirestoreQuery)) {\n      throw new Error(\n        \"firebase.firestore().collection().isEqual(*) 'other' expected a Query instance.\",\n      );\n    }\n\n    // Carry out lightweight checks first\n    if (\n      this.firestore.app.name !== other.firestore.app.name ||\n      this._modifiers.type !== other._modifiers.type ||\n      this._modifiers.filters.length !== other._modifiers.filters.length ||\n      this._modifiers.orders.length !== other._modifiers.orders.length ||\n      this._collectionPath.relativeName !== other._collectionPath.relativeName ||\n      Object.keys(this._modifiers.options).length !== Object.keys(other._modifiers.options).length\n    ) {\n      return false;\n    }\n\n    // Carry out potentially expensive checks\n    // noinspection RedundantIfStatementJS\n    if (\n      JSON.stringify(this._modifiers.filters) !== JSON.stringify(other._modifiers.filters) ||\n      JSON.stringify(this._modifiers.orders) !== JSON.stringify(other._modifiers.orders) ||\n      JSON.stringify(this._modifiers.options) !== JSON.stringify(other._modifiers.options)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  limit(limit) {\n    if (this._modifiers.isValidLimit(limit)) {\n      throw new Error(\n        \"firebase.firestore().collection().limit(*) 'limit' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limit(limit);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  limitToLast(limitToLast) {\n    if (this._modifiers.isValidLimitToLast(limitToLast)) {\n      throw new Error(\n        \"firebase.firestore().collection().limitToLast(*) 'limitToLast' must be a positive integer value.\",\n      );\n    }\n\n    const modifiers = this._modifiers._copy().limitToLast(limitToLast);\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  onSnapshot(...args) {\n    let snapshotListenOptions;\n    let callback;\n    let onNext;\n    let onError;\n\n    this._modifiers.validatelimitToLast();\n\n    try {\n      const options = parseSnapshotArgs(args);\n      snapshotListenOptions = options.snapshotListenOptions;\n      callback = options.callback;\n      onNext = options.onNext;\n      onError = options.onError;\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().onSnapshot(*) ${e.message}`);\n    }\n\n    function handleSuccess(querySnapshot) {\n      callback(querySnapshot, null);\n      onNext(querySnapshot);\n    }\n\n    function handleError(error) {\n      callback(null, error);\n      onError(error);\n    }\n\n    const listenerId = _id++;\n\n    const onSnapshotSubscription = this._firestore.emitter.addListener(\n      this._firestore.eventNameForApp(`firestore_collection_sync_event:${listenerId}`),\n      event => {\n        if (event.body.error) {\n          handleError(NativeError.fromEvent(event.body.error, 'firestore'));\n        } else {\n          const querySnapshot = new FirestoreQuerySnapshot(\n            this._firestore,\n            this,\n            event.body.snapshot,\n          );\n          handleSuccess(querySnapshot);\n        }\n      },\n    );\n\n    const unsubscribe = () => {\n      onSnapshotSubscription.remove();\n      this._firestore.native.collectionOffSnapshot(listenerId);\n    };\n\n    if (!isUndefined(this._queryName)) {\n      this._firestore.native.namedQueryOnSnapshot(\n        this._queryName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        listenerId,\n        snapshotListenOptions,\n      );\n    } else {\n      this._firestore.native.collectionOnSnapshot(\n        this._collectionPath.relativeName,\n        this._modifiers.type,\n        this._modifiers.filters,\n        this._modifiers.orders,\n        this._modifiers.options,\n        listenerId,\n        snapshotListenOptions,\n      );\n    }\n\n    return unsubscribe;\n  }\n\n  orderBy(fieldPath, directionStr) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(*) 'fieldPath' must be a string or instance of FieldPath.\",\n      );\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().orderBy(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!isUndefined(directionStr) && !this._modifiers.isValidDirection(directionStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().orderBy(_, *) 'directionStr' must be one of 'asc' or 'desc'.\",\n      );\n    }\n\n    if (this._modifiers.hasStart()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call startAt() or startAfter() before calling orderBy().',\n      );\n    }\n\n    if (this._modifiers.hasEnd()) {\n      throw new Error(\n        'firebase.firestore().collection().orderBy() Invalid query. You must not call endAt() or endBefore() before calling orderBy().',\n      );\n    }\n\n    const modifiers = this._modifiers._copy().orderBy(path, directionStr);\n\n    try {\n      modifiers.validateOrderBy();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().orderBy() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n\n  startAfter(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAfter', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  startAt(docOrField, ...fields) {\n    return new FirestoreQuery(\n      this._firestore,\n      this._collectionPath,\n      this._handleQueryCursor('startAt', docOrField, fields),\n      this._queryName,\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    if (!isString(fieldPath) && !(fieldPath instanceof FirestoreFieldPath)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(*) 'fieldPath' must be a string or instance of FieldPath.\",\n      );\n    }\n\n    let path;\n\n    if (isString(fieldPath)) {\n      try {\n        path = fromDotSeparatedString(fieldPath);\n      } catch (e) {\n        throw new Error(`firebase.firestore().collection().where(*) 'fieldPath' ${e.message}.`);\n      }\n    } else {\n      path = fieldPath;\n    }\n\n    if (!this._modifiers.isValidOperator(opStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, *) 'opStr' is invalid. Expected one of '==', '>', '>=', '<', '<=', '!=', 'array-contains', 'not-in', 'array-contains-any' or 'in'.\",\n      );\n    }\n\n    if (isUndefined(value)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, _, *) 'value' argument expected.\",\n      );\n    }\n\n    if (isNull(value) && !this._modifiers.isEqualOperator(opStr)) {\n      throw new Error(\n        \"firebase.firestore().collection().where(_, _, *) 'value' is invalid. You can only perform equals comparisons on null\",\n      );\n    }\n\n    if (this._modifiers.isInOperator(opStr)) {\n      if (!isArray(value) || !value.length) {\n        throw new Error(\n          `firebase.firestore().collection().where(_, _, *) 'value' is invalid. A non-empty array is required for '${opStr}' filters.`,\n        );\n      }\n\n      if (value.length > 10) {\n        throw new Error(\n          `firebase.firestore().collection().where(_, _, *) 'value' is invalid. '${opStr}' filters support a maximum of 10 elements in the value array.`,\n        );\n      }\n    }\n\n    const modifiers = this._modifiers._copy().where(path, opStr, value);\n\n    try {\n      modifiers.validateWhere();\n    } catch (e) {\n      throw new Error(`firebase.firestore().collection().where() ${e.message}`);\n    }\n\n    return new FirestoreQuery(this._firestore, this._collectionPath, modifiers, this._queryName);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}