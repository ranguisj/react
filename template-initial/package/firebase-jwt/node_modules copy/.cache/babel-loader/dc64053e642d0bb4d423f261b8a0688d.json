{"ast":null,"code":"/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nimport { isObject } from '@react-native-firebase/app/lib/common';\nimport FirestoreDocumentReference from './FirestoreDocumentReference';\nimport { parseSetOptions, parseUpdateArgs } from './utils';\nimport { buildNativeMap } from './utils/serialize';\nexport default class FirestoreWriteBatch {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._writes = [];\n    this._committed = false;\n  }\n\n  _verifyNotCommitted(method) {\n    if (this._committed) {\n      throw new Error(`firebase.firestore.batch().${method}(*) A write batch can no longer be used after commit() has been called.`);\n    }\n  }\n\n  commit() {\n    this._verifyNotCommitted('commit');\n\n    this._committed = true;\n\n    if (this._writes.length === 0) {\n      return Promise.resolve();\n    }\n\n    return this._firestore.native.documentBatch(this._writes);\n  }\n\n  delete(documentRef) {\n    this._verifyNotCommitted('delete');\n\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\"firebase.firestore.batch().delete(*) 'documentRef' expected instance of a DocumentReference.\");\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\"firebase.firestore.batch().delete(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\");\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'DELETE'\n    });\n\n    return this;\n  }\n\n  set(documentRef, data, options) {\n    this._verifyNotCommitted('set');\n\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\"firebase.firestore.batch().set(*) 'documentRef' expected instance of a DocumentReference.\");\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\"firebase.firestore.batch().set(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\");\n    }\n\n    if (!isObject(data)) {\n      throw new Error(\"firebase.firestore.batch().set(_, *) 'data' must be an object.\");\n    }\n\n    let setOptions;\n\n    try {\n      setOptions = parseSetOptions(options);\n    } catch (e) {\n      throw new Error(`firebase.firestore().doc().set(_, *) ${e.message}.`);\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'SET',\n      data: buildNativeMap(data, this._firestore._settings.ignoreUndefinedProperties),\n      options: setOptions\n    });\n\n    return this;\n  }\n\n  update(documentRef) {\n    this._verifyNotCommitted('update');\n\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\"firebase.firestore.batch().update(*) 'documentRef' expected instance of a DocumentReference.\");\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\"firebase.firestore.batch().update(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\");\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n      throw new Error('firebase.firestore.batch().update(_, *) Invalid arguments. Expected update object or list of key/value pairs.');\n    }\n\n    let data;\n\n    try {\n      data = parseUpdateArgs(args);\n    } catch (e) {\n      throw new Error(`firebase.firestore().batch().update(_, *) ${e.message}`);\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'UPDATE',\n      data: buildNativeMap(data, this._firestore._settings.ignoreUndefinedProperties)\n    });\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/jeremyranguis/greatwanderline/package/firebase-jwt/node_modules/@react-native-firebase/firestore/lib/FirestoreWriteBatch.js"],"names":["isObject","FirestoreDocumentReference","parseSetOptions","parseUpdateArgs","buildNativeMap","FirestoreWriteBatch","constructor","firestore","_firestore","_writes","_committed","_verifyNotCommitted","method","Error","commit","length","Promise","resolve","native","documentBatch","delete","documentRef","app","push","path","type","set","data","options","setOptions","e","message","_settings","ignoreUndefinedProperties","update","args"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,QAAT,QAAyB,uCAAzB;AACA,OAAOC,0BAAP,MAAuC,8BAAvC;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,SAAjD;AACA,SAASC,cAAT,QAA+B,mBAA/B;AAEA,eAAe,MAAMC,mBAAN,CAA0B;AACvCC,EAAAA,WAAW,CAACC,SAAD,EAAY;AACrB,SAAKC,UAAL,GAAkBD,SAAlB;AACA,SAAKE,OAAL,GAAe,EAAf;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACD;;AAEDC,EAAAA,mBAAmB,CAACC,MAAD,EAAS;AAC1B,QAAI,KAAKF,UAAT,EAAqB;AACnB,YAAM,IAAIG,KAAJ,CACH,8BAA6BD,MAAO,yEADjC,CAAN;AAGD;AACF;;AAEDE,EAAAA,MAAM,GAAG;AACP,SAAKH,mBAAL,CAAyB,QAAzB;;AACA,SAAKD,UAAL,GAAkB,IAAlB;;AACA,QAAI,KAAKD,OAAL,CAAaM,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,aAAOC,OAAO,CAACC,OAAR,EAAP;AACD;;AACD,WAAO,KAAKT,UAAL,CAAgBU,MAAhB,CAAuBC,aAAvB,CAAqC,KAAKV,OAA1C,CAAP;AACD;;AAEDW,EAAAA,MAAM,CAACC,WAAD,EAAc;AAClB,SAAKV,mBAAL,CAAyB,QAAzB;;AACA,QAAI,EAAEU,WAAW,YAAYpB,0BAAzB,CAAJ,EAA0D;AACxD,YAAM,IAAIY,KAAJ,CACJ,8FADI,CAAN;AAGD;;AAED,QAAIQ,WAAW,CAACd,SAAZ,CAAsBe,GAAtB,KAA8B,KAAKd,UAAL,CAAgBc,GAAlD,EAAuD;AACrD,YAAM,IAAIT,KAAJ,CACJ,uHADI,CAAN;AAGD;;AAED,SAAKJ,OAAL,CAAac,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAEH,WAAW,CAACG,IADF;AAEhBC,MAAAA,IAAI,EAAE;AAFU,KAAlB;;AAKA,WAAO,IAAP;AACD;;AAEDC,EAAAA,GAAG,CAACL,WAAD,EAAcM,IAAd,EAAoBC,OAApB,EAA6B;AAC9B,SAAKjB,mBAAL,CAAyB,KAAzB;;AACA,QAAI,EAAEU,WAAW,YAAYpB,0BAAzB,CAAJ,EAA0D;AACxD,YAAM,IAAIY,KAAJ,CACJ,2FADI,CAAN;AAGD;;AAED,QAAIQ,WAAW,CAACd,SAAZ,CAAsBe,GAAtB,KAA8B,KAAKd,UAAL,CAAgBc,GAAlD,EAAuD;AACrD,YAAM,IAAIT,KAAJ,CACJ,oHADI,CAAN;AAGD;;AAED,QAAI,CAACb,QAAQ,CAAC2B,IAAD,CAAb,EAAqB;AACnB,YAAM,IAAId,KAAJ,CAAU,gEAAV,CAAN;AACD;;AAED,QAAIgB,UAAJ;;AACA,QAAI;AACFA,MAAAA,UAAU,GAAG3B,eAAe,CAAC0B,OAAD,CAA5B;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV,YAAM,IAAIjB,KAAJ,CAAW,wCAAuCiB,CAAC,CAACC,OAAQ,GAA5D,CAAN;AACD;;AAED,SAAKtB,OAAL,CAAac,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAEH,WAAW,CAACG,IADF;AAEhBC,MAAAA,IAAI,EAAE,KAFU;AAGhBE,MAAAA,IAAI,EAAEvB,cAAc,CAACuB,IAAD,EAAO,KAAKnB,UAAL,CAAgBwB,SAAhB,CAA0BC,yBAAjC,CAHJ;AAIhBL,MAAAA,OAAO,EAAEC;AAJO,KAAlB;;AAOA,WAAO,IAAP;AACD;;AAEDK,EAAAA,MAAM,CAACb,WAAD,EAAuB;AAC3B,SAAKV,mBAAL,CAAyB,QAAzB;;AACA,QAAI,EAAEU,WAAW,YAAYpB,0BAAzB,CAAJ,EAA0D;AACxD,YAAM,IAAIY,KAAJ,CACJ,8FADI,CAAN;AAGD;;AAED,QAAIQ,WAAW,CAACd,SAAZ,CAAsBe,GAAtB,KAA8B,KAAKd,UAAL,CAAgBc,GAAlD,EAAuD;AACrD,YAAM,IAAIT,KAAJ,CACJ,uHADI,CAAN;AAGD;;AAZ0B,sCAANsB,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAc3B,QAAIA,IAAI,CAACpB,MAAL,KAAgB,CAApB,EAAuB;AACrB,YAAM,IAAIF,KAAJ,CACJ,+GADI,CAAN;AAGD;;AAED,QAAIc,IAAJ;;AACA,QAAI;AACFA,MAAAA,IAAI,GAAGxB,eAAe,CAACgC,IAAD,CAAtB;AACD,KAFD,CAEE,OAAOL,CAAP,EAAU;AACV,YAAM,IAAIjB,KAAJ,CAAW,6CAA4CiB,CAAC,CAACC,OAAQ,EAAjE,CAAN;AACD;;AAED,SAAKtB,OAAL,CAAac,IAAb,CAAkB;AAChBC,MAAAA,IAAI,EAAEH,WAAW,CAACG,IADF;AAEhBC,MAAAA,IAAI,EAAE,QAFU;AAGhBE,MAAAA,IAAI,EAAEvB,cAAc,CAACuB,IAAD,EAAO,KAAKnB,UAAL,CAAgBwB,SAAhB,CAA0BC,yBAAjC;AAHJ,KAAlB;;AAMA,WAAO,IAAP;AACD;;AAnHsC","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isObject } from '@react-native-firebase/app/lib/common';\nimport FirestoreDocumentReference from './FirestoreDocumentReference';\nimport { parseSetOptions, parseUpdateArgs } from './utils';\nimport { buildNativeMap } from './utils/serialize';\n\nexport default class FirestoreWriteBatch {\n  constructor(firestore) {\n    this._firestore = firestore;\n    this._writes = [];\n    this._committed = false;\n  }\n\n  _verifyNotCommitted(method) {\n    if (this._committed) {\n      throw new Error(\n        `firebase.firestore.batch().${method}(*) A write batch can no longer be used after commit() has been called.`,\n      );\n    }\n  }\n\n  commit() {\n    this._verifyNotCommitted('commit');\n    this._committed = true;\n    if (this._writes.length === 0) {\n      return Promise.resolve();\n    }\n    return this._firestore.native.documentBatch(this._writes);\n  }\n\n  delete(documentRef) {\n    this._verifyNotCommitted('delete');\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\n        \"firebase.firestore.batch().delete(*) 'documentRef' expected instance of a DocumentReference.\",\n      );\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\n        \"firebase.firestore.batch().delete(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\",\n      );\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'DELETE',\n    });\n\n    return this;\n  }\n\n  set(documentRef, data, options) {\n    this._verifyNotCommitted('set');\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\n        \"firebase.firestore.batch().set(*) 'documentRef' expected instance of a DocumentReference.\",\n      );\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\n        \"firebase.firestore.batch().set(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\",\n      );\n    }\n\n    if (!isObject(data)) {\n      throw new Error(\"firebase.firestore.batch().set(_, *) 'data' must be an object.\");\n    }\n\n    let setOptions;\n    try {\n      setOptions = parseSetOptions(options);\n    } catch (e) {\n      throw new Error(`firebase.firestore().doc().set(_, *) ${e.message}.`);\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'SET',\n      data: buildNativeMap(data, this._firestore._settings.ignoreUndefinedProperties),\n      options: setOptions,\n    });\n\n    return this;\n  }\n\n  update(documentRef, ...args) {\n    this._verifyNotCommitted('update');\n    if (!(documentRef instanceof FirestoreDocumentReference)) {\n      throw new Error(\n        \"firebase.firestore.batch().update(*) 'documentRef' expected instance of a DocumentReference.\",\n      );\n    }\n\n    if (documentRef.firestore.app !== this._firestore.app) {\n      throw new Error(\n        \"firebase.firestore.batch().update(*) 'documentRef' provided DocumentReference is from a different Firestore instance.\",\n      );\n    }\n\n    if (args.length === 0) {\n      throw new Error(\n        'firebase.firestore.batch().update(_, *) Invalid arguments. Expected update object or list of key/value pairs.',\n      );\n    }\n\n    let data;\n    try {\n      data = parseUpdateArgs(args);\n    } catch (e) {\n      throw new Error(`firebase.firestore().batch().update(_, *) ${e.message}`);\n    }\n\n    this._writes.push({\n      path: documentRef.path,\n      type: 'UPDATE',\n      data: buildNativeMap(data, this._firestore._settings.ignoreUndefinedProperties),\n    });\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}